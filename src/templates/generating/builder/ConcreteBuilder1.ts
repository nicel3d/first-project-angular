/**
 * Классы Конкретного Строителя следуют интерфейсу Строителя и предоставляют
 * конкретные реализации шагов построения. Ваша программа может иметь несколько
 * вариантов Строителей, реализованных по-разному.
 */
import { IBuilder } from './IBuilder';
import { Product1 } from './Product1';

export class ConcreteBuilder1 implements IBuilder {
  private product: Product1;

  /**
   * Новый экземпляр строителя должен содержать пустой объект продукта,
   * который используется в дальнейшей сборке.
   */
  constructor() {
    this.reset();
  }

  public reset(): void {
    this.product = new Product1();
  }

  /**
   * Все этапы производства работают с одним и тем же экземпляром продукта.
   */
  public producePartA(): void {
    this.product.parts.push('PartA1');
  }

  public producePartB(): void {
    this.product.parts.push('PartB1');
  }

  public producePartC(): void {
    this.product.parts.push('PartC1');
  }

  /**
   * Конкретные Строители должны предоставить свои собственные методы
   * получения результатов. Это связано с тем, что различные типы строителей
   * могут создавать совершенно разные продукты с разными интерфейсами.
   * Поэтому такие методы не могут быть объявлены в базовом интерфейсе
   * Строителя (по крайней мере, в статически типизированном языке
   * программирования).
   *
   * Как правило, после возвращения конечного результата клиенту, экземпляр
   * строителя должен быть готов к началу производства следующего продукта.
   * Поэтому обычной практикой является вызов метода сброса в конце тела
   * метода getProduct. Однако такое поведение не является обязательным, вы
   * можете заставить своих строителей ждать явного запроса на сброс из кода
   * клиента, прежде чем избавиться от предыдущего результата.
   */
  public getProduct(): Product1 {
    const result = this.product;
    this.reset();
    return result;
  }
}
